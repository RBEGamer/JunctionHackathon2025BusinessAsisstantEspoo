const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');

const repoRoot = process.cwd();
const baseDir = path.join(repoRoot, 'track_definitons');
const routingPath = path.join(baseDir, 'track_routing.yaml');

function safeLoadYaml(filePath) {
  try {
    const content = fs.readFileSync(filePath, 'utf8');
    return yaml.load(content);
  } catch (err) {
    console.warn(`Warning: failed to load YAML ${filePath}: ${err.message}`);
    return null;
  }
}

const routing = safeLoadYaml(routingPath);
if (!routing || !Array.isArray(routing.routing)) {
  console.error('No valid routing entries found in', routingPath);
  process.exit(1);
}

const tracks = routing.routing.map(entry => {
  const defFile = path.join(baseDir, entry.file || '');
  const def = safeLoadYaml(defFile) || {};
  // Some definition files use `options: [ ... ]` â€” take first option when present
  const definition = def.options && Array.isArray(def.options) ? def.options[0] : def;

  return {
    trackId: entry.track_id,
    file: entry.file,
    order: entry.order || 0,
    required: !!entry.required,
    category: entry.category || null,
    description: entry.description || definition.summary || '',
    prerequisites: entry.prerequisites || [],
    mutually_exclusive_with: entry.mutually_exclusive_with || [],
    is_terminal: !!entry.is_terminal,
    definition: definition || null,
  };
});

const outDir = path.join(repoRoot, 'src_new_interface', 'data');
if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });
const outPath = path.join(outDir, 'tracks.js');
const banner = '// This file is auto-generated by scripts/compile-tracks.cjs\n';
const fileContent = banner + 'export default ' + JSON.stringify(tracks, null, 2) + '\n';
fs.writeFileSync(outPath, fileContent, 'utf8');
console.log('Generated', outPath, 'with', tracks.length, 'tracks');
